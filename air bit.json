{"README.md":"\n> Open this page at [https://gomakekit.github.io/airbit_v2/](https://gomakekit.github.io/airbit_v2/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/gomakekit/airbit_v2** and import\n\n## Edit this project ![Build status badge](https://github.com/gomakekit/airbit_v2/workflows/MakeCode/badge.svg)\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/gomakekit/airbit_v2** and click import\n\n## Blocks preview\n\nThis image shows the blocks code from the last commit in master.\nThis image may take a few minutes to refresh.\n\n![A rendered view of the blocks](https://github.com/gomakekit/airbit_v2/raw/master/.github/makecode/blocks.png)\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","custom.ts":"\n/**\n* Use this file to define custom export functions and blocks.\n* Read more at https://makecode.microbit.org/blocks/custom\n*/\n\nenum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"ïƒƒ\"\nnamespace airbit {\n\n\n    /**\n    * Draw a vertical bar with gradients for prescicion\n    * X = 0..4 x position on screen, amount = 0..100\n    */\n\n    //% blockID=airbit_smart_bar\n    //% block=\"Smart Bar $x $amount\"\n    //% group='Screen'\n    //% x.min = 0 x.max=4\n    //% amount.min = 0 amount.max = 100\n\n    export function smartBar(x: number, amount: number) {\n        for (let index = 0; index <= amount / 20; index++) {\n            led.plot(x, 4 - index)\n        }\n        led.plotBrightness(x, 4 - Math.floor(amount / 20), 12.75 * (amount % 20))\n    }\n\n    /**\n     * Initialise Barometer\n     */\n\n    //% blockID=airbit_start_baro\n    //% block=\"Start Barometer\"\n    //% group='Control'\n    export function baroStart() {\n        // Soft reset\n        pins.i2cWriteNumber(\n            BARO_REG_SLAVEADR,\n            32861,\n            NumberFormat.UInt16BE,\n            true\n        )\n        basic.pause(10)\n        pins.i2cWriteNumber(\n            BARO_REG_SLAVEADR,\n            61384,\n            NumberFormat.UInt16BE,\n            true\n        )\n        BARO_return = pins.i2cReadNumber(BARO_REG_SLAVEADR, NumberFormat.UInt16LE, true)\n        if (BARO_return) {\n            basic.showString(\"B\")\n        } else {\n            basic.showString(\"No Baro\", 50)\n        }\n    }\n\n\n    /**\n     * Erase PID registers\n     */\n\n    //% blockID=airbit_clean_reg\n    //% block=\"Clean Registers\"\n    //% group='Control'\n\n    export function cleanReg() {\n        rollDiff = 0\n        pitchDiff = 0\n        lastRollDiff = 0\n        lastPitchDiff = 0\n        lastYawDiff = 0\n        rollIdiff = 0\n        pitchIdiff = 0\n        yawIdiff = 0\n        yawDiff = 0\n        yawDdiff = 0\n        lastRollDiff = 0\n        lastPitchDiff = 0\n      \n        pitchPdiff = 0\n        rollPdiff = 0\n        pitchDdiff = 0\n        rollDdiff = 0\n        imuYaw = 0\n        gyroZdelta = 0\n        yaw = 0\n        rollCorrection = 0\n        pitchCorrection = 0\n\n    }\n\n    //let batteryVoltage = 0\n    //  let batterymVoltSmooth = 0\n    /**\n     * Battery level in %\n     */\n    //% blockID=airbit_battery_level\n    //% block=\"Battery Level\"\n    //% group='Battery management'\n\n    export function batteryLevel() {\n        batteryCalculation()\n        return Math.map(batterymVoltSmooth, 3400, 4200, 0, 100)\n    }\n\n\n    /**\n    *   Battery calculation with smoothing (low pass filter)\n    */\n\n    //% blockID=airbit_battery_calculation\n    //% block=\"Battery Calculation\"\n    //% group='Battery management'\n\n    export function batteryCalculation() {\n        batterymVoltSmooth = Math.round(pins.analogReadPin(AnalogPin.P0) * BATTERY_FACTOR * 0.1 + batterymVoltSmooth * 0.9)\n\n    }\n\n    /**\n       Battery calculation (no smoothing) \n    */\n\n    //% blockID=airbit_battery_calculation_simple\n    //% block=\"Battery milliVolts\"\n    //% group='Battery management'\n\n    export function batterymVolt() {\n        return Math.round(pins.analogReadPin(AnalogPin.P0) * BATTERY_FACTOR)\n\n    }\n\n\n\n\n    /**\n     * Read from the motor controller\n     */\n\n    //% blockID=airbit_read_pca\n    //% block=\"Read Motor Controller\"\n    //% group='System'\n\n    export function readPCA(num: number) {\n        pins.i2cWriteNumber(\n            PCA_REG_SLAVEADR,\n            num,\n            NumberFormat.UInt8BE,\n            true\n        )\n        return pins.i2cReadNumber(PCA_REG_SLAVEADR, NumberFormat.UInt8BE, false)\n    }\n\n\n\n    export function radioSend() {\n        radio.sendValue(\"B\", batterymVoltSmooth)\n        radio.sendValue(\"G\", input.acceleration(Dimension.Z))\n        radio.sendValue(\"Te\", input.temperature())\n        radio.sendValue(\"Rd\", Math.round(imuRoll))\n        radio.sendValue(\"Pd\", Math.round(imuPitch))\n    }\n\n    /*\n        export function PCA_ReadMode2() {\n            pins.i2cWriteNumber(\n                PCA_REG_SLAVEADR,\n                PCA_REG_MODE2,\n                NumberFormat.UInt8BE,\n                true\n            )\n            return pins.i2cReadNumber(PCA_REG_SLAVEADR, NumberFormat.UInt8BE, false)\n        }\n        */\n\n\n    \n\n    /**\n     * Calculate the drone's Roll, Pitch and Roll angles from raw data.\n     */\n\n    //% blockID=airbit_calculate_angles\n    //% block=\"Calculate Angles\"\n    //% group='Control'\n\n    export function calculateAngles() {\n        looptime = input.runningTime() - oldTime\n        oldTime = input.runningTime()\n        accPitch = (-57.295 * Math.atan2(accY, accZ)) - accPitchOffset\n        accRoll = (-57.295 * Math.atan2(accX, accZ)) - accRollOffset\n        //accRollTest = accRoll\n        // Degrees away from desired angle\n        gyroXdelta = (gyroX - gyroXcalibration) * looptime * -0.00000762939\n        gyroYdelta = (gyroY - gyroYcalibration) * looptime * 0.00000762939\n        gyroZdelta = (gyroZ - gyroZcalibration) * looptime * -0.00000762939\n        imuRoll = (gyroYdelta + imuRoll) * 0.99 + accRoll * 0.01\n        imuPitch = (gyroXdelta + imuPitch) * 0.99 + accPitch * 0.01\n        // imuRoll = gyroYdelta + imuRoll\n        // gyroYangle = gyroYdelta + gyroYangle\n        // gyroXangle = gyroXdelta + gyroXangle\n        imuYaw = gyroZdelta + imuYaw\n        //serial.writeLine(\"\"+imuYaw)\n    }\n\n    /** \n     * \n     * Plot a rotating dot\n     * xPos and yPos is the center point 0..4\n     * Radius 1..4 (size)\n     * Speed -100..100, use negative value for counter clock rotation\n    */\n    //% blockID=airbit_rotation_dot\n    //% block=\"Rotation dot $xPos $yPos $radius $speed\"\n    //% xPos.min=0 xPos.max=4 xPos.dfl=2\n    //% yPos.min=0 yPos.max=4 yPos.dfl=2\n    //% radius.min=1 radius.max=4 radius.dfl=2\n    //% speed.min=-100 speed.max=100 speed.dfl=10\n    //% group='Screen'\n\n    export function rotateDot(xPos: number, yPos: number, radius: number, speed: number) {\n        led.plot(xPos + 0.5 + (radius+0.5) * Math.cos(input.runningTime() / 10000 * 6.283 * speed), yPos + 0.5 + (radius+0.5) * Math.sin(input.runningTime() / 10000 * 6.283 * speed))\n    }\n\n\n\n    /**\n        Control the individual speed of each motor.\n     */\n    //% blockID=airbit_motor_speed\n    //% block=\"Motor Speed $m0 $m1 $m2 $m3\"\n    //% m0.min=0 m0.max=255\n    //% m1.min=0 m1.max=255\n    //% m2.min=0 m2.max=255\n    //% m3.min=0 m3.max=255\n\n    //% group='Control'\n\n    export function MotorSpeed(m0: number, m1: number, m2: number, m3: number) {\n        pins.i2cWriteNumber(\n            PCA_REG_SLAVEADR,\n            PCA_pwm0 << 8 | m3,\n            NumberFormat.UInt16BE,\n            false\n        )\n        pins.i2cWriteNumber(\n            PCA_REG_SLAVEADR,\n            PCA_pwm1 << 8 | m2,\n            NumberFormat.UInt16BE,\n            false\n        )\n        pins.i2cWriteNumber(\n            PCA_REG_SLAVEADR,\n            PCA_pwm2 << 8 | m1,\n            NumberFormat.UInt16BE,\n            false\n        )\n        pins.i2cWriteNumber(\n            PCA_REG_SLAVEADR,\n            PCA_pwm3 << 8 | m0,\n            NumberFormat.UInt16BE,\n            false\n        )\n    }\n\n\n    /*\n       Start and setup the Gyro/Accelereometer sensor\n    */\n\n    //% blockID=airbit_start_imu\n    //% block=\"Start Gyro/Acc\"\n    //% group='Control'\n\n    export function IMU_Start() {\n        // Full reset chip (H_RESET, internal 20MHz clock)\n        pins.i2cWriteNumber(\n            IMU_REG_ADDRESS,\n            IMU_PWR_MGMT_1 << 8 | 0x80,\n            NumberFormat.UInt16BE,\n            false\n        )\n        basic.pause(500)\n        pins.i2cWriteNumber(\n            IMU_REG_ADDRESS,\n            IMU_WHO_AM_I,\n            NumberFormat.UInt8BE,\n            true\n        )\n        gyroReturnId = pins.i2cReadNumber(IMU_REG_ADDRESS, NumberFormat.Int16BE, false)\n        // basic.showNumber(IMU_Return >> 8)\n        basic.clearScreen()\n        if (gyroReturnId >> 8 > 0) {\n            basic.showString(\"G\")\n            gyroExists = true\n        } else {\n            basic.showString(\"NG\", 50)\n            gyroExists = false\n        }\n        // set clock to internal PLL\n        pins.i2cWriteNumber(\n            IMU_REG_ADDRESS,\n            IMU_PWR_MGMT_1 << 8 | 0x01,\n            NumberFormat.UInt16BE,\n            false\n        )\n        // // place accel and gyro on standby\n        // pins.i2cWriteNumber(\n        // mpuAddress,\n        // imu_PWR_MGMT_2 << 8 | 0x3f,\n        // NumberFormat.UInt16BE,\n        // false\n        // )\n        pins.i2cWriteNumber(\n            IMU_REG_ADDRESS,\n            IMU_SIGNAL_PATH_RESET << 8 | 0x07,\n            NumberFormat.UInt16BE,\n            false\n        )\n        // disable fifo\n        // was 0x01, FIFO only available for serial\n        pins.i2cWriteNumber(\n            IMU_REG_ADDRESS,\n            IMU_USER_CTRL << 8 | 0x00,\n            NumberFormat.UInt16BE,\n            false\n        )\n        // disable fifo\n        // Filter setting: DLP_CFG = 0(250 Hz), 1(176 Hz)\n        pins.i2cWriteNumber(\n            IMU_REG_ADDRESS,\n            IMU_USER_CTRL << 8 | 0x00,\n            NumberFormat.UInt16BE,\n            false\n        )\n        // Gyro filter setting to 0 (250 Hz), 1 (176 Hz),  2 (92 Hz), 3 (41 Hz)\n        pins.i2cWriteNumber(\n            IMU_REG_ADDRESS,\n            IMU_REG_CONFIG << 8 | 0,\n            NumberFormat.UInt16BE,\n            false\n        )\n        // Acc filter setting to 3 (44.8 Hz), 4 (21,2 Hz), 5 (10.2 Hz)\n        pins.i2cWriteNumber(\n            IMU_REG_ADDRESS,\n            IMU_ACCEL_CONFIG_2 << 8 | 5,\n            NumberFormat.UInt16BE,\n            false\n        )\n    }\n\n\n\n    /*\n      Write to the motor controller\n    */\n\n    //% blockID=airbit_write_pca\n    //% block=\"Write PCA\"\n    //% group='System'\n\n    export function PCA_Write(register: number, value: number) {\n        pins.i2cWriteNumber(\n            PCA_REG_SLAVEADR,\n            register << 8 | value,\n            NumberFormat.UInt16BE,\n            false\n        )\n    }\n\n\n    /**\n     * TODO: describe your export function here\n     */\n    //% block\n\n    /*  export function PCA_Off() {\n          PCA_Write(PCA_REG_MODE1, 128)\n          // Inverted, Totem pole on:\n          PCA_Write(PCA_REG_MODE2, 21)\n          // LED0-LED3 individual brightness (no group pwm)\n          pins.i2cWriteNumber(\n              PCA_REG_SLAVEADR,\n              PCA_REG_LEDUOT << 8 | 0,\n              NumberFormat.UInt16BE,\n              false\n          )\n      }\n  \n      */\n\n    // basic.showNumber(0)\n\n\n\n    //gyroX: number, gyroY: number, gyroZ: number, accY: number, accX: number, accZ: number\n\n    /**\n     * Read gyro and acceleration from sensor\n     */\n\n    //% blockID=airbit_read_imu\n    //% block=\"Read Gyro/Acc\"\n    //% group='Control'\n\n    export function IMU_sensorRead() {\n        pins.i2cWriteNumber(\n            IMU_REG_ADDRESS,\n            67,\n            NumberFormat.Int8LE,\n            true\n        )\n        gyroX = pins.i2cReadNumber(104, NumberFormat.Int16BE, true)\n        gyroY = pins.i2cReadNumber(104, NumberFormat.Int16BE, true)\n        gyroZ = pins.i2cReadNumber(104, NumberFormat.Int16BE, false)\n        pins.i2cWriteNumber(\n            104,\n            59,\n            NumberFormat.Int8LE,\n            true\n        )\n        accX = pins.i2cReadNumber(104, NumberFormat.Int16BE, true)\n        accY = pins.i2cReadNumber(104, NumberFormat.Int16BE, true)\n        accZ = pins.i2cReadNumber(104, NumberFormat.Int16BE, false)\n    }\n\n\n\n    // Mode2:\n    // Totem pole:\n    // Inverted = %10101(21)\n    // Non-inverted = %00101(5)\n    // \n    // Open Drain:\n    // Inverted = %10001(17)\n    // Non-inverted = %00001(1)\n\n    /**\n    * Setup motor controller\n    */\n\n    //% blockID=airbit_start_pca\n    //% block=\"Start Motor Controller\"\n    //% group='Control'\n\n    export function PCA_Start() {\n        PCA_Write(PCA_REG_MODE1, 128)\n        PCA_Write(PCA_REG_MODE2, PCA_REG_MODE2_CONFIG)\n        // Mode2:Inverted, Totem pole on = %10101(21), Non-inverted = %00101(5)\n        // Mode2:Inverted, Open drain = %10001(17), Non-inverted = %00001(1)\n        PCA_Write(PCA_REG_LEDUOT, 170)\n\n        MotorSpeed(0, 0, 0, 0)     // Zero out motor speed \n        // Self test to see if data reg can be read.\n        pins.i2cWriteNumber(\n            PCA_REG_SLAVEADR,\n            PCA_REG_MODE2,\n            NumberFormat.UInt8BE,\n            true\n        )\n        mcReturnId = pins.i2cReadNumber(PCA_REG_SLAVEADR, NumberFormat.UInt8BE, false)\n        basic.clearScreen()\n        if (mcReturnId) {\n           // basic.showString(\"M\")             Moved to main code, startup\n            mcExists = true\n        } else {\n           // basic.showString(\"No PCA!\", 50)   Moved to main code, startup\n            mcExists = false\n        }\n    }\n\n\n\n\n    /**\n    * Calibrate the gyro\n    */\n    //% block\n\n    /**\n    * Calibrate the gyro and accelerometer\n    */\n    //% blockID=Calibrate Gyro / Acc\n    //% block=\"Calibrate the offsets for gyro and accelerometer\"\n\n\n\n    //% blockID=airbit_calibrate_gyro\n    //% block=\"Calibrate Gyro/Acc\"\n    //% group='Control'\n\n    export function IMU_gyro_calibrate() {\n        gyroXcalibration = 0\n        gyroYcalibration = 0\n        gyroZcalibration = 0\n        let steadyCount = 0\n        let filterShake = 0\n        let filterDelta = 0\n        let oldFilterDelta = 0\n        basic.showString(\"C\")\n        IMU_sensorRead()\n        calculateAngles()\n        //accPitch = -57.295 * Math.atan2(accY, accZ)\n        //accRoll = -57.295 * Math.atan2(accX, accZ)\n\n\n        while (Math.abs(accRoll) > 2 || Math.abs(accPitch) > 2 ){\n        IMU_sensorRead()\n        calculateAngles()\n        //accPitch = -57.295 * Math.atan2(accY, accZ)\n        //accRoll = -57.295 * Math.atan2(accX, accZ)\n        basic.showString(\"Lay flat\",100)\n        \n        }\n\n    while (steadyCount < 100) {\n        IMU_sensorRead()\n        filterDelta = input.acceleration(Dimension.Strength) - oldFilterDelta\n        oldFilterDelta = input.acceleration(Dimension.Strength)\n        filterShake = Math.abs(filterDelta) * 0.1 + filterShake * 0.9\n        //serial.writeValue(\"x\", filterShake)\n        accPitch = -57.295 * Math.atan2(accY, accZ)\n        accRoll = -57.295 * Math.atan2(accX, accZ)\n        basic.clearScreen()\n\n        for (let i = 0; i < steadyCount / 20; i++) {\n       // led.plot(i,0)   \n       // led.plot(i,4) \n        led.plot(0,4-i)\n        led.plot(4,4-i)\n        }\n        led.plot(accRoll/4+2.5,-accPitch/4+2.5)\n        led.plot(accRoll / 4 + 3.5, -accPitch / 4 + 2.5)\n        led.plot(accRoll / 4 + 1.5, -accPitch / 4 + 2.5)\n        led.plot(accRoll / 4 + 2.5, -accPitch / 4 + 1.5)\n        led.plot(accRoll / 4 + 2.5, -accPitch / 4 + 3.5)\n\n        if (Math.abs(accRoll)< 2  && Math.abs(accPitch) < 2 && filterShake < 10) {\n            steadyCount +=1\n        } else {\n            steadyCount = 0\n        }\n        //serial.writeValue(\"x\",steadyCount)\n        //serial.writeValue(\"x\", Math.abs(input.acceleration(Dimension.Strength)-oldStrength))\n        //oldStrength = input.acceleration(Dimension.Strength)\n        //serial.writeValue(\"y\", accRoll)\n        basic.pause(20)\n        }\n\n\n        for (let index = 0; index < 100; index++) {\n            IMU_sensorRead()\n            gyroXcalibration += gyroX\n            gyroYcalibration += gyroY\n            gyroZcalibration += gyroZ\n            basic.pause(5)\n        }\n        gyroXcalibration = gyroXcalibration / 100\n        gyroYcalibration = gyroYcalibration / 100\n        gyroZcalibration = gyroZcalibration / 100\n        accPitch = -57.295 * Math.atan2(accY, accZ)\n        accRoll = -57.295 * Math.atan2(accX, accZ)\n        accPitchOffset = accPitch\n        accRollOffset = accRoll\n\n        //accPitchOffset = 0\n        //accRollOffset = 0\n\n        basic.showIcon(IconNames.Yes)\n    }\n\n\n\n\n    /**\n     * Use PID algorithm to generate the four motor speeds \n     */\n\n    //% blockID=airbit_stabilise_pid\n    //% block=\"Stabilise PID\"\n    //% group='Control'\n\n\n    export function stabilisePid() {\n\n        rollDiff = roll - imuRoll\n        pitchDiff = pitch - imuPitch      // Reversing the pitch\n        yawDiff = yaw - imuYaw\n        rollDdiff = rollDiff - lastRollDiff\n        pitchDdiff = pitchDiff - lastPitchDiff\n        yawDdiff = yawDiff - lastYawDiff\n\n        lastRollDiff = rollDiff\n        lastPitchDiff = pitchDiff\n        lastYawDiff = yawDiff\n\n        let iRange = 5      //  Maximal error that will increase Roll and Pitch integral\n        let iLimit = 4      //  Maximal correcton that can be added by integral\n        let yawLimit = 50   //  Maximal yaw correction \n       \n        if (throttle > 50) {    // Prevent windup before flight\n\n            if (rollDiff > - iRange && rollDiff < iRange ){\n                rollIdiff += rollDiff\n            }\n            if (pitchDiff > - iRange && pitchDiff < iRange) {\n                pitchIdiff += pitchDiff\n            }\n\n        }\n\n        let rollIcorrection = rollIdiff * rollPitchI\n        let pitchIcorrection = pitchIdiff * rollPitchI\n\n        rollIcorrection = Math.constrain(rollIcorrection, -iLimit, iLimit)     // Limit I (preventing it from growing out of proportions)\n        pitchIcorrection = Math.constrain(pitchIcorrection, -iLimit, iLimit)\n\n     \n        rollCorrection = rollDiff * rollPitchP + rollIcorrection + rollDdiff * rollPitchD\n        pitchCorrection = pitchDiff * rollPitchP + pitchIcorrection + pitchDdiff * rollPitchD\n        //yawCorrection = yawDiff * yawP \n        yawCorrection = yawDiff * yawP + yawDdiff * yawD\n        yawCorrection = Math.constrain(yawCorrection, -yawLimit, yawLimit)\n        throttleScaled = throttle * 2.55\n\n        //tuningOut = rollIdiff * rollPitchI\n        //tuningOutA = yawDiff\n        //tuningOutB = rollIcorrection\n\n        // rollCorrection = 0\n        motorA = Math.round(throttleScaled + rollCorrection + pitchCorrection + yawCorrection)\n        motorB = Math.round(throttleScaled + rollCorrection - pitchCorrection - yawCorrection)\n        motorC = Math.round(throttleScaled - rollCorrection + pitchCorrection - yawCorrection)\n        motorD = Math.round(throttleScaled - rollCorrection - pitchCorrection + yawCorrection)\n        motorA = Math.constrain(motorA, 0, 255)\n        motorB = Math.constrain(motorB, 0, 255)\n        motorC = Math.constrain(motorC, 0, 255)\n        motorD = Math.constrain(motorD, 0, 255)\n    }\n\n\n    /**\n     * Frame rate of pid loop\n     */\n    //% block\n\n    export function fps() {\n\n        return Math.round(1000 / looptime)\n    }\n    export function sounds() {\n        if (arm && soundStage == 0) {\n            soundExpression.giggle.playUntilDone()\n            soundStage = 1\n        }\n        if (batteryLev < 50 && soundStage == 1) {\n            soundExpression.slide.playUntilDone()\n            soundStage = 2\n        }\n        if (batteryLev < 20 && soundStage == 2) {\n            soundExpression.sad.playUntilDone()\n            soundStage = 3\n        }\n    }\n    input.onGesture(Gesture.ScreenDown, function () {\n        stable = 0\n    })\n\n\n\n    /**\n     * TODO: describe your export function here\n     * @param n describe parameter here, eg: 5\n     * @param s describe parameter here, eg: \"Hello\"\n     * @param e describe parameter here\n     */\n    //% block\n\n    \n\n    export function PCA_ReadMode1() {\n        pins.i2cWriteNumber(\n            PCA_REG_SLAVEADR,\n            PCA_REG_MODE1,\n            NumberFormat.UInt8BE,\n            true\n        )\n        return pins.i2cReadNumber(PCA_REG_SLAVEADR, NumberFormat.UInt8BE, false)\n    }\n\n\n   // let imuRoll = 0\n    let gyroReturnId = 0\n    let mcReturnId = 0\n    let calibratedRoll = 0\n    let calibratedPitch = 0\n    let throttleScaled = 0\n    let yawCorrection = 0\n    let pitchCorrection = 0\n    let rollCorrection = 0\n    let lastYawDiff = 0\n    let pitchDdiff = 0\n    let pitchDiff = 0\n    let rollDiff = 0\n    let accRollOffset = 0  //  Calibration offset of the Roll\n    let accPitchOffset = 0  //  Calibration offset of the Pitch\n    let soundStage = 0\n    let oldTime = 0\n    let aux = 0\n    let startTime = 0\n    let cpuTime = 0\n    let yawIdiff = 0\n    let yawDiff = 0\n    let rollDdiff = 0\n    let lastPitchDiff = 0\n    let lastRollDiff = 0\n    let pitchIdiff = 0\n    let rollIdiff = 0\n    let yawDdiff = 0\n    let stable = 0\n    let interruptCounter = 0\n    let gyroZcalibration = 0\n    let gyroZ = 0\n    let gyroZdelta = 0\n    let gyroXcalibration = 0\n    let gyroX = 0\n    let gyroXdelta = 0\n    let looptime = 0\n    let gyroYcalibration = 0\n    let gyroY = 0\n    let gyroYdelta = 0\n    let accY = 0\n    let accRoll = 0\n    let accZ = 0\n    let accX = 0\n    let accPitch = 0\n    //   let imuPitch = 0\n    //   let imuRoll = 0\n    let batteryLev = 0\n    let BATTERY_FACTOR = 5.94\n    let arm = 0\n    let mode = 0\n\n\n    let PCA_REG_LEDUOT = 8\n    let PCA_REG_SLAVEADR = 98\n    let PCA_REG_MODE1 = 0\n    let PCA_REG_MODE2 = 1\n    let PCA_pwm0 = 2\n    let PCA_pwm1 = 3\n    let PCA_pwm2 = 4\n    let PCA_pwm3 = 5\n    let PCA_return = 0\n    let BARO_return = 0\n    let pitchPdiff = 0\n    let rollPitchISmall = 0\n    let rollPdiff = 0\n    let gyroYangle = 0\n    let gyroXangle = 0\n    let gyroZangle = 0\n    let tuning = 0\n    let PCA_REG_MODE2_CONFIG = 5        // Non-inverted: Open Drain: = %00001(1), Totem: = %00101(5), Inverted: Totem = %10101(21), Open drain: = %10001(17)\n\n    let IMU_REG_CONFIG = 1          // 0x6b\n    let IMU_PWR_MGMT_1 = 107        // 0x6b\n    let IMU_PWR_MGMT_2 = 108        // 0x6B\n    let IMU_WHO_AM_I = 117              // 0x68\n    let IMU_SIGNAL_PATH_RESET = 105 // 0x6a\n    let IMU_USER_CTRL = 106\n    let IMU_GYRO_CONFIG = 27\n    let IMU_ACCEL_CONFIG = 28\n    let IMU_ACCEL_CONFIG_2 = 29\n    let IMU_REG_ADDRESS = 104\n    let BARO_REG_SLAVEADR = 99\n    let magicNumber = \"P1.5,I0.5,D0.35,Y2.5\"\n    magicNumber = \"P1.2,I20,D0.2,Y2\"\n    magicNumber = \"P1.2,I0.015,D50,Yp20,Yi0.01\"\n    magicNumber = \"git:P1.3,I0.04,D18,Yp4,Yi0.02\"\n    magicNumber = \"P0.5,I0,D15,Yp3,Yi0\"\n    rollPitchP = 0.5\n    rollPitchI = 0\n    rollPitchD = 15\n\n    let radioGroup = 7\n    let motorSpeed = -1\n\n\n\n\n\n}\n\n","main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"TD{ra*m9HXG22Q~vWK2^\">index</variable><variable id=\":RyIFg*?=ose1eu/_=7H\">index2</variable><variable id=\":{d)dS-}qkG~+LR9(hX6\">roll</variable><variable id=\"sbmQRWi)#3OMt;$,OAfC\">pitch</variable><variable id=\"U[AYI%;*Hoo_XMmmI+$9\">arm</variable><variable id=\":Povv@~Q{Krd-#u^}FSl\">mode</variable><variable id=\"PMEVcy5]IvD9mu,2=qJb\">throttle</variable><variable id=\"nxrix2ztCW/^7hn2vVH5\">motorTesting</variable><variable id=\"#osT^rph8SLg6~WYR?e4\">imuRoll</variable><variable id=\"3XQyF*mF$%N(hT:e_P.}\">stable</variable><variable id=\"Bl$C1xID3r{K*RMzH,0u\">mcExists</variable><variable id=\"a|xq#S02n)?6*DPTyhJs\">gyroExists</variable><variable id=\"_)PN4#C|`7sGHLQXOhm!\">notCharging</variable><variable id=\"wX.bskE(~-LhiyB}JzC)\">motorA</variable><variable id=\"z2bo#}cJ-!]8{PG(=e1s\">motorB</variable><variable id=\"p~)Aw;Xi{kn6WLSRA~Ld\">motorC</variable><variable id=\"G,,!k0pPUKK51Vwm}r=S\">motorD</variable><variable id=\".wo]?p:fMG1?%W(NjsXx\">cpuTime</variable><variable id=\"SZZncGA{(j}Jia]5W`%S\">startTime</variable><variable id=\"~bb1r)KvDxH8txDl}7+w\">imuPitch</variable><variable id=\"Wv:$9=(jdb_gnI_M:sRa\">batterymVoltSmooth</variable><variable id=\"HO*Zyck6kRpvQ^K(MgeA\">radioReceivedTime</variable><variable id=\"QI:BTI/OFIBFt@`N2Au/\">yaw</variable><variable id=\"g7|}HBiY}KuSQ#iv_uGn\">AnalogP0Switch</variable><variable id=\"mnIf_/mEY=zqX+w#WJgZ\">index3</variable><variable id=\"Hp]bT$zz=@K#U%%M7);u\">expoSetting</variable><variable id=\"6m]z0M[}e#i},Y:[mz5p\">expoFactor</variable><variable id=\"KD(I_U%YDMl*Db?4+nx-\">imuYaw</variable><variable id=\"bTGyzaY!--7Yq_l!K+Dq\">baroExists</variable><variable id=\"aP/B3oJgB+xvyeeh:P{G\">batteryVolt</variable><variable id=\"leU(6$[Df,gxG*_7`wxw\">radioGroup</variable><variable id=\"0p^L%;jrS[~,!(ycPB#I\">rollPitchP</variable><variable id=\"?|aNZ,:pU%}.aA1$:Rq*\">rollPitchI</variable><variable id=\"/`W-9PQ(cy^CP!P4QDj%\">rollPitchD</variable><variable id=\"d:*+t!H{4HpwMNR@dl$@\">yawP</variable><variable id=\"QP%6E+uKS^5[;9@AW-6$\">yawD</variable></variables><block type=\"pxt-on-start\" x=\"-905\" y=\"-332\"><statement name=\"HANDLER\"><block type=\"controls_repeat_ext\"><value name=\"TIMES\"><shadow type=\"math_whole_number\"><field name=\"NUM\">4</field></shadow></value><statement name=\"DO\"><block type=\"airbit_PCA_Start\"><next><block type=\"airbit_MotorSpeed\"><value name=\"m0\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"255\" label=\"M0\" precision=\"0\"></mutation><field name=\"SLIDER\">255</field></shadow></value><value name=\"m1\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"255\" label=\"M1\" precision=\"0\"></mutation><field name=\"SLIDER\">255</field></shadow></value><value name=\"m2\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"255\" label=\"M2\" precision=\"0\"></mutation><field name=\"SLIDER\">255</field></shadow></value><value name=\"m3\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"255\" label=\"M3\" precision=\"0\"></mutation><field name=\"SLIDER\">255</field></shadow></value><next><block type=\"airbit_rotateDot\"><value name=\"xPos\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"4\" label=\"XPos\" precision=\"0\"></mutation><field name=\"SLIDER\">4</field></shadow></value><value name=\"yPos\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"4\" label=\"YPos\" precision=\"0\"></mutation><field name=\"SLIDER\">4</field></shadow></value><value name=\"radius\"><shadow type=\"math_number_minmax\"><mutation min=\"1\" max=\"4\" label=\"Radius\" precision=\"0\"></mutation><field name=\"SLIDER\">4</field></shadow></value><value name=\"speed\"><shadow type=\"math_number_minmax\"><mutation min=\"-100\" max=\"100\" label=\"Speed\" precision=\"0\"></mutation><field name=\"SLIDER\">100</field></shadow></value></block></next></block></next></block></statement></block></statement></block></xml>","main.ts":"for (let index = 0; index < 4; index++) {\n    airbit.PCA_Start()\n    airbit.MotorSpeed(\n    255,\n    255,\n    255,\n    255\n    )\n    airbit.rotateDot(\n    4,\n    4,\n    4,\n    100\n    )\n}\n","pxt.json":"{\n    \"name\": \"air bit\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"microbit-pxt-i2cpins\": \"github:bsiever/microbit-pxt-i2cpins#v0.0.6\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v3.0.61\",\n        \"tag\": \"v3.0.61\",\n        \"commits\": \"https://github.com/microsoft/pxt-microbit/commits/9ff91acb8524c6a52fee90cf7194a4643c424363\",\n        \"target\": \"4.0.16\",\n        \"pxt\": \"6.0.35\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"blocksprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}