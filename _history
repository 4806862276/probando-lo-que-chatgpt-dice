{"entries":[{"timestamp":1735315020238,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s"],[0,"://"],[-1,"developers.google.com/blockly/xml\"><variables><variable id=\"Bk8MLlEN$o5EX;et25d.\">motor1_in1</variable><variable id=\"1q_m}T;}j}E__f_hpKv1\">motor1_in2</variable><variable id=\"(mbuzw:]efl!mzk`8nE3\">motor2_in1</variable><variable id=\"KxLx~sr4EAQ)=REfY`=m\">motor2_in2</variable></variables><block type=\"device_button_event\" x=\"476\" y=\"0\"><field name=\"NAME\">Button.A</field><comment pinned=\"false\" h=\"80\" w=\"160\">Controlar los motores para mover hacia adelante cuando se presiona A</comment><statement name=\"HANDLER\"><block type=\"device_set_digital_pin\"><comment pinned=\"false\" h=\"80\" w=\"160\">Avanza motor 1</comment><value name=\"name\"><shadow type=\"digital_pin_shadow\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"Bk8MLlEN$o5EX;et25d.\">motor1_in1</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">1</field></shadow></value><next><block type=\"device_set_digital_pin\"><value name=\"name\"><shadow type=\"digital_pin_shadow\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"1q_m}T;}j}E__f_hpKv1\">motor1_in2</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value><next><block type=\"device_set_digital_pin\"><comment pinned=\"false\" h=\"80\" w=\"160\">Avanza motor 2</comment><value name=\"name\"><shadow type=\"digital_pin_shadow\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"(mbuzw:]efl!mzk`8nE3\">motor2_in1</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">1</field></shadow></value><next><block type=\"device_set_digital_pin\"><value name=\"name\"><shadow type=\"digital_pin_shadow\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"KxLx~sr4EAQ)=REfY`=m\">motor2_in2</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value></block></next></block></next></block></next></block></statement></block>"],[1,"www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n"],[0,"</xm"]],"start1":12,"start2":12,"length1":2325,"length2":113}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"// Controlar los motores para mover hacia adelante cuando se presiona A\ninput.onButtonPressed(Button.A, function () {\n    let motor2_in2 = 0\n    let motor2_in1 = 0\n    let motor1_in2 = 0\n    let motor1_in1 = 0\n    // Avanza motor 1\n    pins.digitalWritePin(motor1_in1, 1)\n    pins.digitalWritePin(motor1_in2, 0)\n    // Avanza motor 2\n    pins.digitalWritePin(motor2_in1, 1)\n    pins.digitalWritePin(motor2_in2, 0)\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":417,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"air bit\": \"pkg:air bit.json\""],[0,"\n   "]],"start1":155,"start2":155,"length1":47,"length2":8},{"diffs":[[0,".md\""],[-1,",\n        \"air bit.json\"\n    ],\n    \"preferredEditor\": \"blocksprj\""],[1,"\n    ],\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":239,"start2":239,"length1":73,"length2":44}]}]},{"timestamp":1735315242850,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"iables><"],[1,"block type=\"device_button_event\" x=\"476\" y=\"0\"><field name=\"NAME\">Button.A</field><comment pinned=\"false\" h=\"80\" w=\"160\">Controlar los motores para mover hacia adelante cuando se presiona A</comment><statement name=\"HANDLER\"><block type=\"device_set_digital_pin\"><comment pinned=\"false\" h=\"80\" w=\"160\">Avanza motor 1</comment><value name=\"name\"><shadow type=\"digital_pin_shadow\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"Bk8MLlEN$o5EX;et25d.\">motor1_in1</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">1</field></shadow></value><next><block type=\"device_set_digital_pin\"><value name=\"name\"><shadow type=\"digital_pin_shadow\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"1q_m}T;}j}E__f_hpKv1\">motor1_in2</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value><next><block type=\"device_set_digital_pin\"><comment pinned=\"false\" h=\"80\" w=\"160\">Avanza motor 2</comment><value name=\"name\"><shadow type=\"digital_pin_shadow\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"(mbuzw:]efl!mzk`8nE3\">motor2_in1</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">1</field></shadow></value><next><block type=\"device_set_digital_pin\"><value name=\"name\"><shadow type=\"digital_pin_shadow\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\"><field name=\"VAR\" id=\"KxLx~sr4EAQ)=REfY`=m\">motor2_in2</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value></block></next></block></next></block></next></block></statement></block><"],[0,"/xml>"]],"start1":299,"start2":299,"length1":13,"length2":2040}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"// "],[-1,"Definir los pines de los motores\nlet motor1_in1 = DigitalPin.P0\nlet motor1_in2 = DigitalPin.P1\nlet motor2_in1 = DigitalPin.P2\nlet motor2_in2 = DigitalPin.P8\n\n// Inicializar los motores apagados\npins.digitalWritePin(motor1_in1, 0)\npins.digitalWritePin("],[1,"Controlar los motores para mover hacia adelante cuando se presiona A\ninput.onButtonPressed(Button.A, function () {\n    let "],[0,"motor"],[-1,"1"],[1,"2"],[0,"_in2"],[-1,", 0)\npins.digitalWritePin(motor2_in1, 0)\npins.digitalWritePin("],[1," = 0\n    let motor2_in1 = 0\n    let "],[0,"motor"],[-1,"2"],[1,"1"],[0,"_in2"],[-1,", 0)\n\n// Función para hacer volar el dron\nfunction fly() {\n    // Aumentar la velocidad para elevar los"],[1," = 0\n    let motor1_in1 = 0\n    // Avanza"],[0," motor"],[-1,"es"],[1," 1"],[0,"\n   "]],"start1":0,"start2":0,"length1":451,"length2":235},{"diffs":[[0,"(motor1_in2, 0)\n"],[1,"    // Avanza motor 2\n"],[0,"    pins.digital"]],"start1":296,"start2":296,"length1":32,"length2":54},{"diffs":[[0," 0)\n"],[-1,"\n    // Espera 2 segundos para simular el vuelo ascendente\n    basic.pause(2000) // Tiempo para subir 1 metro (aproximadamente)\n\n    // Mantener el dron estable por 1 segundo\n    basic.pause(1000) // Tiempo para estabilizar\n\n    // Aterrizar el dron\n    pins.digitalWritePin(motor1_in1, 0)\n    pins.digitalWritePin(motor1_in2, 0)\n    pins.digitalWritePin(motor2_in1, 0)\n    pins.digitalWritePin(motor2_in2, 0)\n}\n\n// Ejecutar la función de vuelo\nfly("],[1,"}"],[0,")\n"],[-1,"\n"]],"start1":410,"start2":410,"length1":456,"length2":7}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"t"],[1,"block"],[0,"sprj\"\n}\n"]],"start1":330,"start2":330,"length1":17,"length2":21}]}]},{"timestamp":1735315748456,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"// "],[-1,"Configura"],[1,"Definir"],[0," los"]],"start1":0,"start2":0,"length1":16,"length2":14},{"diffs":[[0,"Pin.P8\n\n"],[1,"// Inicializar los motores apagados\npins.digitalWritePin(motor1_in1, 0)\npins.digitalWritePin(motor1_in2, 0)\npins.digitalWritePin(motor2_in1, 0)\npins.digitalWritePin(motor2_in2, 0)\n\n"],[0,"// Funci"]],"start1":153,"start2":153,"length1":16,"length2":197},{"diffs":[[0," // "],[-1,"Enciende los motores para hacer que el dron suba"],[1,"Aumentar la velocidad para elevar los motores"],[0,"\n   "]],"start1":398,"start2":398,"length1":56,"length2":53},{"diffs":[[0," // "],[-1,"El dron sube por 2 segundos"],[1,"Tiempo para subir 1 metro (aproximadamente)"],[0,"\n\n  "]],"start1":688,"start2":688,"length1":35,"length2":51},{"diffs":[[0,"Mant"],[-1,"én"],[1,"ener"],[0," el "]],"start1":744,"start2":744,"length1":10,"length2":12},{"diffs":[[0," // "],[-1,"El dron se mantiene en el aire por 1 segundo\n\n    // Apaga los motores para a"],[1,"Tiempo para estabilizar\n\n    // A"],[0,"terr"]],"start1":804,"start2":804,"length1":85,"length2":41},{"diffs":[[0," Ejecuta"],[1,"r"],[0," la func"]],"start1":1023,"start2":1023,"length1":16,"length2":17},{"diffs":[[0," vuelo\nfly()"],[1,"\n\n"]],"start1":1046,"start2":1046,"length1":12,"length2":14}]}]},{"timestamp":1735316319390,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"itor\": \""],[-1,"block"],[1,"t"],[0,"sprj\"\n}\n"]],"start1":330,"start2":330,"length1":21,"length2":17}]}]},{"timestamp":1735320798778,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"input.onButtonPressed(Button.A, function () {\n    radiotest = 0\n})\nlet radiotest = 0\nlet arm = 0\nlet raidiokanal = 8\nradio.setGroup(raidiokanal)\nbasic.showString(\"\" + (raidiokanal))\nlet putefart = 350\nwhile (arm) {\n    basic.showIcon(IconNames.No)\n}\nbasic.showIcon(IconNames.Yes)\nbasic.forever("],[1,"// Configura los pines de los motores\nlet motor1_in1 = DigitalPin.P0\nlet motor1_in2 = DigitalPin.P1\nlet motor2_in1 = DigitalPin.P2\nlet motor2_in2 = DigitalPin.P8\n\n// Función para hacer volar el dron\n"],[0,"func"]],"start1":0,"start2":0,"length1":298,"length2":203},{"diffs":[[0,"unction "],[1,"fly"],[0,"() {\n   "]],"start1":200,"start2":200,"length1":16,"length2":19},{"diffs":[[0,"    "],[-1,"let rool2 = 0\n    if (arm) {\n        let trottle = 0\n  "],[1,"// Enciende los motores para hacer que el dron suba\n    pins.digitalWritePin(motor1_in1, 1)\n    pins.digitalWritePin(motor1_in2, 0)\n"],[0,"    "],[-1,"  "],[0,"pins."],[-1,"analog"],[1,"digital"],[0,"Writ"]],"start1":216,"start2":216,"length1":80,"length2":156},{"diffs":[[0,"Pin("],[-1,"AnalogPin.P0, putefart"],[1,"motor2_in1, 1"],[0,")\n    "],[-1," "],[-1,"   "],[0,"pins."],[-1,"analog"],[1,"digital"],[0,"Writ"]],"start1":373,"start2":373,"length1":51,"length2":39},{"diffs":[[0,"Pin("],[-1,"AnalogPin.P2, trottle * 10)\n    } else {\n    "],[1,"motor2_in2, 0)\n\n    // Espera 2 segundos para simular el vuelo ascendente\n    basic.pause(2000) // El dron sube por 2 segundos\n\n    // Mantén el dron estable por 1 segundo\n    basic.pause(1000) // El dron se mantiene en el aire por 1 segundo\n\n    // Apaga los motores para aterrizar el dron\n"],[0,"    "]],"start1":413,"start2":413,"length1":53,"length2":299},{"diffs":[[0,"l dron\n    pins."],[-1,"analog"],[1,"digital"],[0,"WritePin(AnalogP"]],"start1":701,"start2":701,"length1":38,"length2":39},{"diffs":[[0,"Pin("],[-1,"AnalogPin.P0"],[1,"motor1_in1"],[0,", 0)"]],"start1":729,"start2":729,"length1":20,"length2":18},{"diffs":[[0," 0)\n    "],[-1," "],[-1,"   "],[0,"pins."],[-1,"analog"],[1,"digital"],[0,"WritePin"]],"start1":744,"start2":744,"length1":31,"length2":28},{"diffs":[[0,"Pin("],[-1,"AnalogPin.P2, 0)\n    }\n    pins.analogWritePin(AnalogPin.P1, rool2 + 90)\n    if (radiotest) {\n        basic.pause(5000)\n    }\n})\n"],[1,"motor1_in2, 0)\n    pins.digitalWritePin(motor2_in1, 0)\n    pins.digitalWritePin(motor2_in2, 0)\n}\n\n// Ejecuta la función de vuelo\nfly()"]],"start1":769,"start2":769,"length1":133,"length2":138}]}]},{"timestamp":1735320798786,"editorVersion":"7.0.51","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"id=\""],[-1,"5ZCqE6WcDb,g.Y6QBx8p\">motor1_in1</variable><variable id=\"E/t1!D!_r4toYtB)PZdJ\">motor1_in2</variable><variable id=\";h(x*l^9Kkz=_5.;@`;3\">motor2_in1</variable><variable id=\"cOtrSG*EVn.|JZ!2rbp#\">motor2_in2</variable></variables><block type=\"function_definition\" id=\"b,`{bsq-~K-/)fZJRL^M\" x=\"500\" y=\"-21\"><mutation name=\"fly\" functionid=\"Q4-+tyilBE/$nn+1E3WI\"></mutation><field name=\"function_name\">fly</field><comment pinned=\"false\" h=\"80\" w=\"160\">Función para hacer volar el dron</comment><statement name=\"STACK\"><block type=\"device_set_digital_pin\" id=\"AaM86BQk4M7*xp*G9te^\"><comment pinned=\"false\" h=\"80\" w=\"160\">Enciende los motores para hacer que el dron suba</comment><value name=\"name\"><shadow type=\"digital_pin_shadow\" id=\"[UG|,S_Dj(^M6hUD=T7J\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\" id=\"vQci`h=u!7Tb)GCfjjtR\"><field name=\"VAR\" id=\"5ZCqE6WcDb,g.Y6QBx8p\">motor1_in1</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\" id=\"*98q#@Yu53N)m/_v,)m?\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">1</field></shadow></value><next><block type=\"device_set_digital_pin\" id=\"~CJ9OZN9JnOaG8cyMddM\"><value name=\"name\"><shadow type=\"digital_pin_shadow\" id=\")DI^Ha4yaFKZ~Cu~W@#/\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\" id=\"Yhg_V5xGZ3twG#9-;VCd\"><field name=\"VAR\" id=\"E/t1!D!_r4toYtB)PZdJ\">motor1_in2</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\" id=\")e~1K0Jrq($+*+byrUlS\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value><next><block type=\"device_set_digital_pin\" id=\"DA][AX%^ntl!Uc6*G-]=\"><value name=\"name\"><shadow type=\"digital_pin_shadow\" id=\"7dS=jl)uoXzH@HqU?sJi\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\" id=\"?)!39|5@-,jq*Fe4EI|c\"><field name=\"VAR\" id=\";h(x*l^9Kkz=_5.;@`;3\">motor2_in1</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\" id=\")92OyOAnM_(*)QTSG$!y\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">1</field></shadow></value><next><block type=\"device_set_digital_pin\" id=\"G]_aj$zEiOO7F4wd-,6u\"><value name=\"name\"><shadow type=\"digital_pin_shadow\" id=\"9i|jA@#9@+rA@[nC{-MN\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\" id=\"w17bQE^hR?0@K//+B#Z^\"><field name=\"VAR\" id=\"cOtrSG*EVn.|JZ!2rbp#"],[1,"Bk8MLlEN$o5EX;et25d.\">motor1_in1</variable><variable id=\"1q_m}T;}j}E__f_hpKv1"],[0,"\">motor"],[-1,"2"],[1,"1"],[0,"_in2</"],[-1,"field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\" id=\"F=(GT-bKX1sk)DRemA@%\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value><next><block type=\"device_pause\" id=\"7mdey,v(6VV6[XtWOlc)\"><comment pinned=\"false\" h=\"80\" w=\"160\">Espera 2 segundos para simular el vuelo ascendente\nEl dron sube por 2 segundos</comment><value name=\"pause\"><shadow type=\"timePicker\" id=\"/}zYSXFm(}+.P}]ECDIv\"><field name=\"ms\">2000</field></shadow></value><next><block type=\"device_pause\" id=\"aTR#Mb}S7rcHu4mUeM-)\"><comment pinned=\"false\" h=\"80\" w=\"160\">Mantén el dron estable por 1 segundo\nEl dron se mantiene en el aire por 1 segundo</comment><value name=\"pause\"><shadow type=\"timePicker\" id=\"aX_qYnkU+UfNZ!)234KW\"><field name=\"ms\">1000</field></shadow></value><next><block type=\"device_set_digital_pin\" id=\"c@KETjqeR9y#c,BeBtuH\"><comment pinned=\"false\" h=\"80\" w=\"160\">Apaga los motores para aterrizar el dron</comment><value name=\"name\"><shadow type=\"digital_pin_shadow\" id=\"lpIBF5.vs-JZxf8z`z3~\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\" id=\"V_40%a:8FU4oO@Dc0IM,\"><field name=\"VAR\" id=\"5ZCqE6WcDb,g.Y6QBx8p\">motor1_in1</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\" id=\"-$UFS6pt2%hKM]PyhH-K\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value><next><block type=\"device_set_digital_pin\" id=\"%DSd!@m,9m-o5_$g}-Or\"><value name=\"name\"><shadow type=\"digital_pin_shadow\" id=\"xM{a%*P9YgrsUdbx,6lk\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\" id=\"sk+.59)4?wn2q)Zvn#B`\"><field name=\"VAR\" id=\"E/t1!D!_r4toYtB)PZdJ\">motor1_in2</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\" id=\"-(619YOiFm%P`g9F|[]P\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value><next><block type=\"device_set_digital_pin\" id=\"TN`;I;_#?~*bTb$}Oe:f\"><value name=\"name\"><shadow type=\"digital_pin_shadow\" id=\"v0pN!l@GPH;buj9C4V(%\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\" id=\"^Z5jH%(R1:c=[f/sIFLL\"><field name=\"VAR\" id=\";h(x*l^9Kkz=_5.;@`;3\">motor2_in1</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\" id=\"3%`9;+pXg=5buaZ0%Kh3\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value><next><block type=\"device_set_digital_pin\" id=\")o}.@byTzTy-D2gANILS\"><value name=\"name\"><shadow type=\"digital_pin_shadow\" id=\"^YdBoa:N!GX25|xtbR@5\"><field name=\"pin\">DigitalPin.P0</field></shadow><block type=\"variables_get\" id=\",Bh#GkL_c^WaVf^9Up/Z\"><field name=\"VAR\" id=\"cOtrSG*EVn.|JZ!2rbp#\">motor2_in2</field></block></value><value name=\"value\"><shadow type=\"math_number_minmax\" id=\"+b;r!=!tO@Re[3Pogsan\"><mutation min=\"0\" max=\"1\" precision=\"0\"></mutation><field name=\"SLIDER\">0</field></shadow></value></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block><block type=\"pxt-on-start\" id=\"`SaOfosOc}NJYz4Uh`],\" x=\"20\" y=\"20\"><statement name=\"HANDLER\"><block type=\"variables_set\" id=\"}LQDR4AXU/+;[E+hM3L}\"><field name=\"VAR\" id=\"5ZCqE6WcDb,g.Y6QBx8p\">motor1_in1</field><comment pinned=\"false\" h=\"80\" w=\"160\">Configura los pines de los motores</comment><value name=\"VALUE\"><shadow type=\"math_number\" id=\"jFbUhki4*PnHT_=QKao9\"><field name=\"NUM\">0</field></shadow><block type=\"digital_pin\" id=\"SYU}A|u=,53_,9+8#]rb\"><field name=\"pin\">DigitalPin.P0</field></block></value><next><block type=\"variables_set\" id=\"[1Q~?S!0$UytV._h,qk=\"><field name=\"VAR\" id=\"E/t1!D!_r4toYtB)PZdJ\">motor1_in2</field><value name=\"VALUE\"><shadow type=\"math_number\" id=\"k.0))dPNMWeDsIp`xszG\"><field name=\"NUM\">0</field></shadow><block type=\"digital_pin\" id=\":6B:KOINbj?wJvXJ]all\"><field name=\"pin\">DigitalPin.P1</field></block></value><next><block type=\"variables_set\" id=\"6yt#1.AN*PLlx@s#;04Y\"><field name=\"VAR\" id=\";h(x*l^9Kkz=_5.;@`;3\">motor2_in1</field><value name=\"VALUE\"><shadow type=\"math_number\" id=\"*eoc;=YPxSV%yl)?|!(s\"><field name=\"NUM\">0</field></shadow><block type=\"digital_pin\" id=\"~sXucvAITd;-h5w$zCDr\"><field name=\"pin\">DigitalPin.P2</field></block></value><next><block type=\"variables_set\" id=\"/J,KkjkJ}qtBGr.,U7eX\"><field name=\"VAR\" id=\"cOtrSG*EVn.|JZ!2rbp#\">motor2_in2</field><value name=\"VALUE\"><shadow type=\"math_number\" id=\"@7`A(%%#mkwjcL{obpsf\"><field name=\"NUM\">0</field></shadow><block type=\"digital_pin\" id=\"a/l:11:C9isgi]Ek_T:~\"><field name=\"pin\">DigitalPin.P8</field></block></value><next><block type=\"function_call\" id=\"#oQJrfK_`fys~h1V=g+S\"><mutation name=\"fly\" functionid=\"Q4-+tyilBE/$nn+1E3WI\"></mutation><comment pinned=\"false\" h=\"80\" w=\"160\">Ejecuta la función de vuelo</comment></block></next></block></next></block></next></block></next></block></statement></block"],[1,"variable><variable id=\"(mbuzw:]efl!mzk`8nE3\">motor2_in1</variable><variable id=\"KxLx~sr4EAQ)=REfY`=m\">motor2_in2</variable></variables"],[0,"></x"]],"start1":76,"start2":76,"length1":7333,"length2":233}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"// Función para hacer volar el dron\n"],[1,"input.onButtonPressed(Button.A, "],[0,"func"]],"start1":0,"start2":0,"length1":40,"length2":36},{"diffs":[[0,"ion "],[-1,"fly "],[0,"() {"]],"start1":37,"start2":37,"length1":12,"length2":8},{"diffs":[[0,"    "],[-1,"// Enciende los motores para hacer que el dron suba\n    pins.digitalWritePin(motor1_in1, 1)\n    pins.digitalWritePin(motor1_in2, 0)\n    pins.digitalWritePin(motor2_in1, 1)\n    pins.digitalWritePin(motor2_in2, 0)\n    // Espera 2 segundos para simular el vuelo ascendente\n    // El dron sube por 2 segundos\n    basic.pause(2000)\n    // Mantén el dron estable por 1 segundo\n    // El dron se mantiene en el aire por 1 segundo\n    basic.pause(1000)\n    // Apaga los motores para aterrizar el dron\n"],[1,"radiotest = 0\n})\nlet radiotest = 0\nlet arm = 0\nlet raidiokanal = 8\nradio.setGroup(raidiokanal)\nbasic.showString(\"\" + (raidiokanal))\nlet putefart = 350\nwhile (arm) {\n    basic.showIcon(IconNames.No)\n}\nbasic.showIcon(IconNames.Yes)\nbasic.forever(function () {\n    let rool2 = 0\n    if (arm) {\n        let trottle = 0\n    "],[0,"    "]],"start1":46,"start2":46,"length1":501,"length2":327},{"diffs":[[0," 0\n        pins."],[-1,"digital"],[1,"analog"],[0,"WritePin(motor1_"]],"start1":362,"start2":362,"length1":39,"length2":38},{"diffs":[[0,"Pin("],[-1,"motor1_in1, 0)\n"],[1,"AnalogPin.P0, putefart)\n    "],[0,"    "]],"start1":389,"start2":389,"length1":23,"length2":36},{"diffs":[[0,"t)\n        pins."],[-1,"digital"],[1,"analog"],[0,"WritePin(motor1_"]],"start1":414,"start2":414,"length1":39,"length2":38},{"diffs":[[0,"Pin("],[-1,"motor1_in2, 0)\n    pins.digitalWritePin(motor2_in1"],[1,"AnalogPin.P2, trottle * 10)\n    } else {\n        pins.analogWritePin(AnalogPin.P0"],[0,", 0)"]],"start1":441,"start2":441,"length1":58,"length2":89},{"diffs":[[0,"    "],[1," "],[1,"   "],[0,"pins."],[-1,"digital"],[1,"analog"],[0,"Writ"]],"start1":531,"start2":531,"length1":20,"length2":23},{"diffs":[[0,"Pin("],[-1,"motor2_in2, 0)\n}\nlet motor2_in2 = 0\nlet motor2_in1 = 0\nlet motor1_in2 = 0\nlet motor1_in1 = 0\n// Configura los pines de los motores\nmotor1_in1 = DigitalPin.P0\nmotor1_in2 = DigitalPin.P1\nmotor2_in1 = DigitalPin.P2\nmotor2_in2 = DigitalPin.P8\n// Ejecuta la función de vuelo\nfly("],[1,"AnalogPin.P2, 0)\n    }\n    pins.analogWritePin(AnalogPin.P1, rool2 + 90)\n    if (radiotest) {\n        basic.pause(5000)\n    }\n}"],[0,")\n"]],"start1":555,"start2":555,"length1":280,"length2":133}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0,"ne\": \"*\""],[1,",\n        \"air bit\": \"pkg:air bit.json\""],[0,"\n    },\n"]],"start1":151,"start2":151,"length1":16,"length2":55},{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":310,"start2":310,"length1":52,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1735315020237,"editorVersion":"7.0.51","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"probando lo que chatgpt dice\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1735320798778,"editorVersion":"7.0.51","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"Bk8MLlEN$o5EX;et25d.\">motor1_in1</variable><variable id=\"1q_m}T;}j}E__f_hpKv1\">motor1_in2</variable><variable id=\"(mbuzw:]efl!mzk`8nE3\">motor2_in1</variable><variable id=\"KxLx~sr4EAQ)=REfY`=m\">motor2_in2</variable></variables></xml>","main.ts":"// Configura los pines de los motores\nlet motor1_in1 = DigitalPin.P0\nlet motor1_in2 = DigitalPin.P1\nlet motor2_in1 = DigitalPin.P2\nlet motor2_in2 = DigitalPin.P8\n\n// Función para hacer volar el dron\nfunction fly() {\n    // Enciende los motores para hacer que el dron suba\n    pins.digitalWritePin(motor1_in1, 1)\n    pins.digitalWritePin(motor1_in2, 0)\n    pins.digitalWritePin(motor2_in1, 1)\n    pins.digitalWritePin(motor2_in2, 0)\n\n    // Espera 2 segundos para simular el vuelo ascendente\n    basic.pause(2000) // El dron sube por 2 segundos\n\n    // Mantén el dron estable por 1 segundo\n    basic.pause(1000) // El dron se mantiene en el aire por 1 segundo\n\n    // Apaga los motores para aterrizar el dron\n    pins.digitalWritePin(motor1_in1, 0)\n    pins.digitalWritePin(motor1_in2, 0)\n    pins.digitalWritePin(motor2_in1, 0)\n    pins.digitalWritePin(motor2_in2, 0)\n}\n\n// Ejecuta la función de vuelo\nfly()","README.md":"","air bit.json":"{\"README.md\":\"\\n> Open this page at [https://gomakekit.github.io/airbit_v2/](https://gomakekit.github.io/airbit_v2/)\\n\\n## Use as Extension\\n\\nThis repository can be added as an **extension** in MakeCode.\\n\\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\\n* click on **New Project**\\n* click on **Extensions** under the gearwheel menu\\n* search for **https://github.com/gomakekit/airbit_v2** and import\\n\\n## Edit this project ![Build status badge](https://github.com/gomakekit/airbit_v2/workflows/MakeCode/badge.svg)\\n\\nTo edit this repository in MakeCode.\\n\\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\\n* click on **Import** then click on **Import URL**\\n* paste **https://github.com/gomakekit/airbit_v2** and click import\\n\\n## Blocks preview\\n\\nThis image shows the blocks code from the last commit in master.\\nThis image may take a few minutes to refresh.\\n\\n![A rendered view of the blocks](https://github.com/gomakekit/airbit_v2/raw/master/.github/makecode/blocks.png)\\n\\n#### Metadata (used for search, rendering)\\n\\n* for PXT/microbit\\n<script src=\\\"https://makecode.com/gh-pages-embed.js\\\"></script><script>makeCodeRender(\\\"{{ site.makecode.home_url }}\\\", \\\"{{ site.github.owner_name }}/{{ site.github.repository_name }}\\\");</script>\\n\",\"custom.ts\":\"\\n/**\\n* Use this file to define custom export functions and blocks.\\n* Read more at https://makecode.microbit.org/blocks/custom\\n*/\\n\\nenum MyEnum {\\n    //% block=\\\"one\\\"\\n    One,\\n    //% block=\\\"two\\\"\\n    Two\\n}\\n\\n/**\\n * Custom blocks\\n */\\n//% weight=100 color=#0fbc11 icon=\\\"\\\"\\nnamespace airbit {\\n\\n\\n    /**\\n    * Draw a vertical bar with gradients for prescicion\\n    * X = 0..4 x position on screen, amount = 0..100\\n    */\\n\\n    //% blockID=airbit_smart_bar\\n    //% block=\\\"Smart Bar $x $amount\\\"\\n    //% group='Screen'\\n    //% x.min = 0 x.max=4\\n    //% amount.min = 0 amount.max = 100\\n\\n    export function smartBar(x: number, amount: number) {\\n        for (let index = 0; index <= amount / 20; index++) {\\n            led.plot(x, 4 - index)\\n        }\\n        led.plotBrightness(x, 4 - Math.floor(amount / 20), 12.75 * (amount % 20))\\n    }\\n\\n    /**\\n     * Initialise Barometer\\n     */\\n\\n    //% blockID=airbit_start_baro\\n    //% block=\\\"Start Barometer\\\"\\n    //% group='Control'\\n    export function baroStart() {\\n        // Soft reset\\n        pins.i2cWriteNumber(\\n            BARO_REG_SLAVEADR,\\n            32861,\\n            NumberFormat.UInt16BE,\\n            true\\n        )\\n        basic.pause(10)\\n        pins.i2cWriteNumber(\\n            BARO_REG_SLAVEADR,\\n            61384,\\n            NumberFormat.UInt16BE,\\n            true\\n        )\\n        BARO_return = pins.i2cReadNumber(BARO_REG_SLAVEADR, NumberFormat.UInt16LE, true)\\n        if (BARO_return) {\\n            basic.showString(\\\"B\\\")\\n        } else {\\n            basic.showString(\\\"No Baro\\\", 50)\\n        }\\n    }\\n\\n\\n    /**\\n     * Erase PID registers\\n     */\\n\\n    //% blockID=airbit_clean_reg\\n    //% block=\\\"Clean Registers\\\"\\n    //% group='Control'\\n\\n    export function cleanReg() {\\n        rollDiff = 0\\n        pitchDiff = 0\\n        lastRollDiff = 0\\n        lastPitchDiff = 0\\n        lastYawDiff = 0\\n        rollIdiff = 0\\n        pitchIdiff = 0\\n        yawIdiff = 0\\n        yawDiff = 0\\n        yawDdiff = 0\\n        lastRollDiff = 0\\n        lastPitchDiff = 0\\n      \\n        pitchPdiff = 0\\n        rollPdiff = 0\\n        pitchDdiff = 0\\n        rollDdiff = 0\\n        imuYaw = 0\\n        gyroZdelta = 0\\n        yaw = 0\\n        rollCorrection = 0\\n        pitchCorrection = 0\\n\\n    }\\n\\n    //let batteryVoltage = 0\\n    //  let batterymVoltSmooth = 0\\n    /**\\n     * Battery level in %\\n     */\\n    //% blockID=airbit_battery_level\\n    //% block=\\\"Battery Level\\\"\\n    //% group='Battery management'\\n\\n    export function batteryLevel() {\\n        batteryCalculation()\\n        return Math.map(batterymVoltSmooth, 3400, 4200, 0, 100)\\n    }\\n\\n\\n    /**\\n    *   Battery calculation with smoothing (low pass filter)\\n    */\\n\\n    //% blockID=airbit_battery_calculation\\n    //% block=\\\"Battery Calculation\\\"\\n    //% group='Battery management'\\n\\n    export function batteryCalculation() {\\n        batterymVoltSmooth = Math.round(pins.analogReadPin(AnalogPin.P0) * BATTERY_FACTOR * 0.1 + batterymVoltSmooth * 0.9)\\n\\n    }\\n\\n    /**\\n       Battery calculation (no smoothing) \\n    */\\n\\n    //% blockID=airbit_battery_calculation_simple\\n    //% block=\\\"Battery milliVolts\\\"\\n    //% group='Battery management'\\n\\n    export function batterymVolt() {\\n        return Math.round(pins.analogReadPin(AnalogPin.P0) * BATTERY_FACTOR)\\n\\n    }\\n\\n\\n\\n\\n    /**\\n     * Read from the motor controller\\n     */\\n\\n    //% blockID=airbit_read_pca\\n    //% block=\\\"Read Motor Controller\\\"\\n    //% group='System'\\n\\n    export function readPCA(num: number) {\\n        pins.i2cWriteNumber(\\n            PCA_REG_SLAVEADR,\\n            num,\\n            NumberFormat.UInt8BE,\\n            true\\n        )\\n        return pins.i2cReadNumber(PCA_REG_SLAVEADR, NumberFormat.UInt8BE, false)\\n    }\\n\\n\\n\\n    export function radioSend() {\\n        radio.sendValue(\\\"B\\\", batterymVoltSmooth)\\n        radio.sendValue(\\\"G\\\", input.acceleration(Dimension.Z))\\n        radio.sendValue(\\\"Te\\\", input.temperature())\\n        radio.sendValue(\\\"Rd\\\", Math.round(imuRoll))\\n        radio.sendValue(\\\"Pd\\\", Math.round(imuPitch))\\n    }\\n\\n    /*\\n        export function PCA_ReadMode2() {\\n            pins.i2cWriteNumber(\\n                PCA_REG_SLAVEADR,\\n                PCA_REG_MODE2,\\n                NumberFormat.UInt8BE,\\n                true\\n            )\\n            return pins.i2cReadNumber(PCA_REG_SLAVEADR, NumberFormat.UInt8BE, false)\\n        }\\n        */\\n\\n\\n    \\n\\n    /**\\n     * Calculate the drone's Roll, Pitch and Roll angles from raw data.\\n     */\\n\\n    //% blockID=airbit_calculate_angles\\n    //% block=\\\"Calculate Angles\\\"\\n    //% group='Control'\\n\\n    export function calculateAngles() {\\n        looptime = input.runningTime() - oldTime\\n        oldTime = input.runningTime()\\n        accPitch = (-57.295 * Math.atan2(accY, accZ)) - accPitchOffset\\n        accRoll = (-57.295 * Math.atan2(accX, accZ)) - accRollOffset\\n        //accRollTest = accRoll\\n        // Degrees away from desired angle\\n        gyroXdelta = (gyroX - gyroXcalibration) * looptime * -0.00000762939\\n        gyroYdelta = (gyroY - gyroYcalibration) * looptime * 0.00000762939\\n        gyroZdelta = (gyroZ - gyroZcalibration) * looptime * -0.00000762939\\n        imuRoll = (gyroYdelta + imuRoll) * 0.99 + accRoll * 0.01\\n        imuPitch = (gyroXdelta + imuPitch) * 0.99 + accPitch * 0.01\\n        // imuRoll = gyroYdelta + imuRoll\\n        // gyroYangle = gyroYdelta + gyroYangle\\n        // gyroXangle = gyroXdelta + gyroXangle\\n        imuYaw = gyroZdelta + imuYaw\\n        //serial.writeLine(\\\"\\\"+imuYaw)\\n    }\\n\\n    /** \\n     * \\n     * Plot a rotating dot\\n     * xPos and yPos is the center point 0..4\\n     * Radius 1..4 (size)\\n     * Speed -100..100, use negative value for counter clock rotation\\n    */\\n    //% blockID=airbit_rotation_dot\\n    //% block=\\\"Rotation dot $xPos $yPos $radius $speed\\\"\\n    //% xPos.min=0 xPos.max=4 xPos.dfl=2\\n    //% yPos.min=0 yPos.max=4 yPos.dfl=2\\n    //% radius.min=1 radius.max=4 radius.dfl=2\\n    //% speed.min=-100 speed.max=100 speed.dfl=10\\n    //% group='Screen'\\n\\n    export function rotateDot(xPos: number, yPos: number, radius: number, speed: number) {\\n        led.plot(xPos + 0.5 + (radius+0.5) * Math.cos(input.runningTime() / 10000 * 6.283 * speed), yPos + 0.5 + (radius+0.5) * Math.sin(input.runningTime() / 10000 * 6.283 * speed))\\n    }\\n\\n\\n\\n    /**\\n        Control the individual speed of each motor.\\n     */\\n    //% blockID=airbit_motor_speed\\n    //% block=\\\"Motor Speed $m0 $m1 $m2 $m3\\\"\\n    //% m0.min=0 m0.max=255\\n    //% m1.min=0 m1.max=255\\n    //% m2.min=0 m2.max=255\\n    //% m3.min=0 m3.max=255\\n\\n    //% group='Control'\\n\\n    export function MotorSpeed(m0: number, m1: number, m2: number, m3: number) {\\n        pins.i2cWriteNumber(\\n            PCA_REG_SLAVEADR,\\n            PCA_pwm0 << 8 | m3,\\n            NumberFormat.UInt16BE,\\n            false\\n        )\\n        pins.i2cWriteNumber(\\n            PCA_REG_SLAVEADR,\\n            PCA_pwm1 << 8 | m2,\\n            NumberFormat.UInt16BE,\\n            false\\n        )\\n        pins.i2cWriteNumber(\\n            PCA_REG_SLAVEADR,\\n            PCA_pwm2 << 8 | m1,\\n            NumberFormat.UInt16BE,\\n            false\\n        )\\n        pins.i2cWriteNumber(\\n            PCA_REG_SLAVEADR,\\n            PCA_pwm3 << 8 | m0,\\n            NumberFormat.UInt16BE,\\n            false\\n        )\\n    }\\n\\n\\n    /*\\n       Start and setup the Gyro/Accelereometer sensor\\n    */\\n\\n    //% blockID=airbit_start_imu\\n    //% block=\\\"Start Gyro/Acc\\\"\\n    //% group='Control'\\n\\n    export function IMU_Start() {\\n        // Full reset chip (H_RESET, internal 20MHz clock)\\n        pins.i2cWriteNumber(\\n            IMU_REG_ADDRESS,\\n            IMU_PWR_MGMT_1 << 8 | 0x80,\\n            NumberFormat.UInt16BE,\\n            false\\n        )\\n        basic.pause(500)\\n        pins.i2cWriteNumber(\\n            IMU_REG_ADDRESS,\\n            IMU_WHO_AM_I,\\n            NumberFormat.UInt8BE,\\n            true\\n        )\\n        gyroReturnId = pins.i2cReadNumber(IMU_REG_ADDRESS, NumberFormat.Int16BE, false)\\n        // basic.showNumber(IMU_Return >> 8)\\n        basic.clearScreen()\\n        if (gyroReturnId >> 8 > 0) {\\n            basic.showString(\\\"G\\\")\\n            gyroExists = true\\n        } else {\\n            basic.showString(\\\"NG\\\", 50)\\n            gyroExists = false\\n        }\\n        // set clock to internal PLL\\n        pins.i2cWriteNumber(\\n            IMU_REG_ADDRESS,\\n            IMU_PWR_MGMT_1 << 8 | 0x01,\\n            NumberFormat.UInt16BE,\\n            false\\n        )\\n        // // place accel and gyro on standby\\n        // pins.i2cWriteNumber(\\n        // mpuAddress,\\n        // imu_PWR_MGMT_2 << 8 | 0x3f,\\n        // NumberFormat.UInt16BE,\\n        // false\\n        // )\\n        pins.i2cWriteNumber(\\n            IMU_REG_ADDRESS,\\n            IMU_SIGNAL_PATH_RESET << 8 | 0x07,\\n            NumberFormat.UInt16BE,\\n            false\\n        )\\n        // disable fifo\\n        // was 0x01, FIFO only available for serial\\n        pins.i2cWriteNumber(\\n            IMU_REG_ADDRESS,\\n            IMU_USER_CTRL << 8 | 0x00,\\n            NumberFormat.UInt16BE,\\n            false\\n        )\\n        // disable fifo\\n        // Filter setting: DLP_CFG = 0(250 Hz), 1(176 Hz)\\n        pins.i2cWriteNumber(\\n            IMU_REG_ADDRESS,\\n            IMU_USER_CTRL << 8 | 0x00,\\n            NumberFormat.UInt16BE,\\n            false\\n        )\\n        // Gyro filter setting to 0 (250 Hz), 1 (176 Hz),  2 (92 Hz), 3 (41 Hz)\\n        pins.i2cWriteNumber(\\n            IMU_REG_ADDRESS,\\n            IMU_REG_CONFIG << 8 | 0,\\n            NumberFormat.UInt16BE,\\n            false\\n        )\\n        // Acc filter setting to 3 (44.8 Hz), 4 (21,2 Hz), 5 (10.2 Hz)\\n        pins.i2cWriteNumber(\\n            IMU_REG_ADDRESS,\\n            IMU_ACCEL_CONFIG_2 << 8 | 5,\\n            NumberFormat.UInt16BE,\\n            false\\n        )\\n    }\\n\\n\\n\\n    /*\\n      Write to the motor controller\\n    */\\n\\n    //% blockID=airbit_write_pca\\n    //% block=\\\"Write PCA\\\"\\n    //% group='System'\\n\\n    export function PCA_Write(register: number, value: number) {\\n        pins.i2cWriteNumber(\\n            PCA_REG_SLAVEADR,\\n            register << 8 | value,\\n            NumberFormat.UInt16BE,\\n            false\\n        )\\n    }\\n\\n\\n    /**\\n     * TODO: describe your export function here\\n     */\\n    //% block\\n\\n    /*  export function PCA_Off() {\\n          PCA_Write(PCA_REG_MODE1, 128)\\n          // Inverted, Totem pole on:\\n          PCA_Write(PCA_REG_MODE2, 21)\\n          // LED0-LED3 individual brightness (no group pwm)\\n          pins.i2cWriteNumber(\\n              PCA_REG_SLAVEADR,\\n              PCA_REG_LEDUOT << 8 | 0,\\n              NumberFormat.UInt16BE,\\n              false\\n          )\\n      }\\n  \\n      */\\n\\n    // basic.showNumber(0)\\n\\n\\n\\n    //gyroX: number, gyroY: number, gyroZ: number, accY: number, accX: number, accZ: number\\n\\n    /**\\n     * Read gyro and acceleration from sensor\\n     */\\n\\n    //% blockID=airbit_read_imu\\n    //% block=\\\"Read Gyro/Acc\\\"\\n    //% group='Control'\\n\\n    export function IMU_sensorRead() {\\n        pins.i2cWriteNumber(\\n            IMU_REG_ADDRESS,\\n            67,\\n            NumberFormat.Int8LE,\\n            true\\n        )\\n        gyroX = pins.i2cReadNumber(104, NumberFormat.Int16BE, true)\\n        gyroY = pins.i2cReadNumber(104, NumberFormat.Int16BE, true)\\n        gyroZ = pins.i2cReadNumber(104, NumberFormat.Int16BE, false)\\n        pins.i2cWriteNumber(\\n            104,\\n            59,\\n            NumberFormat.Int8LE,\\n            true\\n        )\\n        accX = pins.i2cReadNumber(104, NumberFormat.Int16BE, true)\\n        accY = pins.i2cReadNumber(104, NumberFormat.Int16BE, true)\\n        accZ = pins.i2cReadNumber(104, NumberFormat.Int16BE, false)\\n    }\\n\\n\\n\\n    // Mode2:\\n    // Totem pole:\\n    // Inverted = %10101(21)\\n    // Non-inverted = %00101(5)\\n    // \\n    // Open Drain:\\n    // Inverted = %10001(17)\\n    // Non-inverted = %00001(1)\\n\\n    /**\\n    * Setup motor controller\\n    */\\n\\n    //% blockID=airbit_start_pca\\n    //% block=\\\"Start Motor Controller\\\"\\n    //% group='Control'\\n\\n    export function PCA_Start() {\\n        PCA_Write(PCA_REG_MODE1, 128)\\n        PCA_Write(PCA_REG_MODE2, PCA_REG_MODE2_CONFIG)\\n        // Mode2:Inverted, Totem pole on = %10101(21), Non-inverted = %00101(5)\\n        // Mode2:Inverted, Open drain = %10001(17), Non-inverted = %00001(1)\\n        PCA_Write(PCA_REG_LEDUOT, 170)\\n\\n        MotorSpeed(0, 0, 0, 0)     // Zero out motor speed \\n        // Self test to see if data reg can be read.\\n        pins.i2cWriteNumber(\\n            PCA_REG_SLAVEADR,\\n            PCA_REG_MODE2,\\n            NumberFormat.UInt8BE,\\n            true\\n        )\\n        mcReturnId = pins.i2cReadNumber(PCA_REG_SLAVEADR, NumberFormat.UInt8BE, false)\\n        basic.clearScreen()\\n        if (mcReturnId) {\\n           // basic.showString(\\\"M\\\")             Moved to main code, startup\\n            mcExists = true\\n        } else {\\n           // basic.showString(\\\"No PCA!\\\", 50)   Moved to main code, startup\\n            mcExists = false\\n        }\\n    }\\n\\n\\n\\n\\n    /**\\n    * Calibrate the gyro\\n    */\\n    //% block\\n\\n    /**\\n    * Calibrate the gyro and accelerometer\\n    */\\n    //% blockID=Calibrate Gyro / Acc\\n    //% block=\\\"Calibrate the offsets for gyro and accelerometer\\\"\\n\\n\\n\\n    //% blockID=airbit_calibrate_gyro\\n    //% block=\\\"Calibrate Gyro/Acc\\\"\\n    //% group='Control'\\n\\n    export function IMU_gyro_calibrate() {\\n        gyroXcalibration = 0\\n        gyroYcalibration = 0\\n        gyroZcalibration = 0\\n        let steadyCount = 0\\n        let filterShake = 0\\n        let filterDelta = 0\\n        let oldFilterDelta = 0\\n        basic.showString(\\\"C\\\")\\n        IMU_sensorRead()\\n        calculateAngles()\\n        //accPitch = -57.295 * Math.atan2(accY, accZ)\\n        //accRoll = -57.295 * Math.atan2(accX, accZ)\\n\\n\\n        while (Math.abs(accRoll) > 2 || Math.abs(accPitch) > 2 ){\\n        IMU_sensorRead()\\n        calculateAngles()\\n        //accPitch = -57.295 * Math.atan2(accY, accZ)\\n        //accRoll = -57.295 * Math.atan2(accX, accZ)\\n        basic.showString(\\\"Lay flat\\\",100)\\n        \\n        }\\n\\n    while (steadyCount < 100) {\\n        IMU_sensorRead()\\n        filterDelta = input.acceleration(Dimension.Strength) - oldFilterDelta\\n        oldFilterDelta = input.acceleration(Dimension.Strength)\\n        filterShake = Math.abs(filterDelta) * 0.1 + filterShake * 0.9\\n        //serial.writeValue(\\\"x\\\", filterShake)\\n        accPitch = -57.295 * Math.atan2(accY, accZ)\\n        accRoll = -57.295 * Math.atan2(accX, accZ)\\n        basic.clearScreen()\\n\\n        for (let i = 0; i < steadyCount / 20; i++) {\\n       // led.plot(i,0)   \\n       // led.plot(i,4) \\n        led.plot(0,4-i)\\n        led.plot(4,4-i)\\n        }\\n        led.plot(accRoll/4+2.5,-accPitch/4+2.5)\\n        led.plot(accRoll / 4 + 3.5, -accPitch / 4 + 2.5)\\n        led.plot(accRoll / 4 + 1.5, -accPitch / 4 + 2.5)\\n        led.plot(accRoll / 4 + 2.5, -accPitch / 4 + 1.5)\\n        led.plot(accRoll / 4 + 2.5, -accPitch / 4 + 3.5)\\n\\n        if (Math.abs(accRoll)< 2  && Math.abs(accPitch) < 2 && filterShake < 10) {\\n            steadyCount +=1\\n        } else {\\n            steadyCount = 0\\n        }\\n        //serial.writeValue(\\\"x\\\",steadyCount)\\n        //serial.writeValue(\\\"x\\\", Math.abs(input.acceleration(Dimension.Strength)-oldStrength))\\n        //oldStrength = input.acceleration(Dimension.Strength)\\n        //serial.writeValue(\\\"y\\\", accRoll)\\n        basic.pause(20)\\n        }\\n\\n\\n        for (let index = 0; index < 100; index++) {\\n            IMU_sensorRead()\\n            gyroXcalibration += gyroX\\n            gyroYcalibration += gyroY\\n            gyroZcalibration += gyroZ\\n            basic.pause(5)\\n        }\\n        gyroXcalibration = gyroXcalibration / 100\\n        gyroYcalibration = gyroYcalibration / 100\\n        gyroZcalibration = gyroZcalibration / 100\\n        accPitch = -57.295 * Math.atan2(accY, accZ)\\n        accRoll = -57.295 * Math.atan2(accX, accZ)\\n        accPitchOffset = accPitch\\n        accRollOffset = accRoll\\n\\n        //accPitchOffset = 0\\n        //accRollOffset = 0\\n\\n        basic.showIcon(IconNames.Yes)\\n    }\\n\\n\\n\\n\\n    /**\\n     * Use PID algorithm to generate the four motor speeds \\n     */\\n\\n    //% blockID=airbit_stabilise_pid\\n    //% block=\\\"Stabilise PID\\\"\\n    //% group='Control'\\n\\n\\n    export function stabilisePid() {\\n\\n        rollDiff = roll - imuRoll\\n        pitchDiff = pitch - imuPitch      // Reversing the pitch\\n        yawDiff = yaw - imuYaw\\n        rollDdiff = rollDiff - lastRollDiff\\n        pitchDdiff = pitchDiff - lastPitchDiff\\n        yawDdiff = yawDiff - lastYawDiff\\n\\n        lastRollDiff = rollDiff\\n        lastPitchDiff = pitchDiff\\n        lastYawDiff = yawDiff\\n\\n        let iRange = 5      //  Maximal error that will increase Roll and Pitch integral\\n        let iLimit = 4      //  Maximal correcton that can be added by integral\\n        let yawLimit = 50   //  Maximal yaw correction \\n       \\n        if (throttle > 50) {    // Prevent windup before flight\\n\\n            if (rollDiff > - iRange && rollDiff < iRange ){\\n                rollIdiff += rollDiff\\n            }\\n            if (pitchDiff > - iRange && pitchDiff < iRange) {\\n                pitchIdiff += pitchDiff\\n            }\\n\\n        }\\n\\n        let rollIcorrection = rollIdiff * rollPitchI\\n        let pitchIcorrection = pitchIdiff * rollPitchI\\n\\n        rollIcorrection = Math.constrain(rollIcorrection, -iLimit, iLimit)     // Limit I (preventing it from growing out of proportions)\\n        pitchIcorrection = Math.constrain(pitchIcorrection, -iLimit, iLimit)\\n\\n     \\n        rollCorrection = rollDiff * rollPitchP + rollIcorrection + rollDdiff * rollPitchD\\n        pitchCorrection = pitchDiff * rollPitchP + pitchIcorrection + pitchDdiff * rollPitchD\\n        //yawCorrection = yawDiff * yawP \\n        yawCorrection = yawDiff * yawP + yawDdiff * yawD\\n        yawCorrection = Math.constrain(yawCorrection, -yawLimit, yawLimit)\\n        throttleScaled = throttle * 2.55\\n\\n        //tuningOut = rollIdiff * rollPitchI\\n        //tuningOutA = yawDiff\\n        //tuningOutB = rollIcorrection\\n\\n        // rollCorrection = 0\\n        motorA = Math.round(throttleScaled + rollCorrection + pitchCorrection + yawCorrection)\\n        motorB = Math.round(throttleScaled + rollCorrection - pitchCorrection - yawCorrection)\\n        motorC = Math.round(throttleScaled - rollCorrection + pitchCorrection - yawCorrection)\\n        motorD = Math.round(throttleScaled - rollCorrection - pitchCorrection + yawCorrection)\\n        motorA = Math.constrain(motorA, 0, 255)\\n        motorB = Math.constrain(motorB, 0, 255)\\n        motorC = Math.constrain(motorC, 0, 255)\\n        motorD = Math.constrain(motorD, 0, 255)\\n    }\\n\\n\\n    /**\\n     * Frame rate of pid loop\\n     */\\n    //% block\\n\\n    export function fps() {\\n\\n        return Math.round(1000 / looptime)\\n    }\\n    export function sounds() {\\n        if (arm && soundStage == 0) {\\n            soundExpression.giggle.playUntilDone()\\n            soundStage = 1\\n        }\\n        if (batteryLev < 50 && soundStage == 1) {\\n            soundExpression.slide.playUntilDone()\\n            soundStage = 2\\n        }\\n        if (batteryLev < 20 && soundStage == 2) {\\n            soundExpression.sad.playUntilDone()\\n            soundStage = 3\\n        }\\n    }\\n    input.onGesture(Gesture.ScreenDown, function () {\\n        stable = 0\\n    })\\n\\n\\n\\n    /**\\n     * TODO: describe your export function here\\n     * @param n describe parameter here, eg: 5\\n     * @param s describe parameter here, eg: \\\"Hello\\\"\\n     * @param e describe parameter here\\n     */\\n    //% block\\n\\n    \\n\\n    export function PCA_ReadMode1() {\\n        pins.i2cWriteNumber(\\n            PCA_REG_SLAVEADR,\\n            PCA_REG_MODE1,\\n            NumberFormat.UInt8BE,\\n            true\\n        )\\n        return pins.i2cReadNumber(PCA_REG_SLAVEADR, NumberFormat.UInt8BE, false)\\n    }\\n\\n\\n   // let imuRoll = 0\\n    let gyroReturnId = 0\\n    let mcReturnId = 0\\n    let calibratedRoll = 0\\n    let calibratedPitch = 0\\n    let throttleScaled = 0\\n    let yawCorrection = 0\\n    let pitchCorrection = 0\\n    let rollCorrection = 0\\n    let lastYawDiff = 0\\n    let pitchDdiff = 0\\n    let pitchDiff = 0\\n    let rollDiff = 0\\n    let accRollOffset = 0  //  Calibration offset of the Roll\\n    let accPitchOffset = 0  //  Calibration offset of the Pitch\\n    let soundStage = 0\\n    let oldTime = 0\\n    let aux = 0\\n    let startTime = 0\\n    let cpuTime = 0\\n    let yawIdiff = 0\\n    let yawDiff = 0\\n    let rollDdiff = 0\\n    let lastPitchDiff = 0\\n    let lastRollDiff = 0\\n    let pitchIdiff = 0\\n    let rollIdiff = 0\\n    let yawDdiff = 0\\n    let stable = 0\\n    let interruptCounter = 0\\n    let gyroZcalibration = 0\\n    let gyroZ = 0\\n    let gyroZdelta = 0\\n    let gyroXcalibration = 0\\n    let gyroX = 0\\n    let gyroXdelta = 0\\n    let looptime = 0\\n    let gyroYcalibration = 0\\n    let gyroY = 0\\n    let gyroYdelta = 0\\n    let accY = 0\\n    let accRoll = 0\\n    let accZ = 0\\n    let accX = 0\\n    let accPitch = 0\\n    //   let imuPitch = 0\\n    //   let imuRoll = 0\\n    let batteryLev = 0\\n    let BATTERY_FACTOR = 5.94\\n    let arm = 0\\n    let mode = 0\\n\\n\\n    let PCA_REG_LEDUOT = 8\\n    let PCA_REG_SLAVEADR = 98\\n    let PCA_REG_MODE1 = 0\\n    let PCA_REG_MODE2 = 1\\n    let PCA_pwm0 = 2\\n    let PCA_pwm1 = 3\\n    let PCA_pwm2 = 4\\n    let PCA_pwm3 = 5\\n    let PCA_return = 0\\n    let BARO_return = 0\\n    let pitchPdiff = 0\\n    let rollPitchISmall = 0\\n    let rollPdiff = 0\\n    let gyroYangle = 0\\n    let gyroXangle = 0\\n    let gyroZangle = 0\\n    let tuning = 0\\n    let PCA_REG_MODE2_CONFIG = 5        // Non-inverted: Open Drain: = %00001(1), Totem: = %00101(5), Inverted: Totem = %10101(21), Open drain: = %10001(17)\\n\\n    let IMU_REG_CONFIG = 1          // 0x6b\\n    let IMU_PWR_MGMT_1 = 107        // 0x6b\\n    let IMU_PWR_MGMT_2 = 108        // 0x6B\\n    let IMU_WHO_AM_I = 117              // 0x68\\n    let IMU_SIGNAL_PATH_RESET = 105 // 0x6a\\n    let IMU_USER_CTRL = 106\\n    let IMU_GYRO_CONFIG = 27\\n    let IMU_ACCEL_CONFIG = 28\\n    let IMU_ACCEL_CONFIG_2 = 29\\n    let IMU_REG_ADDRESS = 104\\n    let BARO_REG_SLAVEADR = 99\\n    let magicNumber = \\\"P1.5,I0.5,D0.35,Y2.5\\\"\\n    magicNumber = \\\"P1.2,I20,D0.2,Y2\\\"\\n    magicNumber = \\\"P1.2,I0.015,D50,Yp20,Yi0.01\\\"\\n    magicNumber = \\\"git:P1.3,I0.04,D18,Yp4,Yi0.02\\\"\\n    magicNumber = \\\"P0.5,I0,D15,Yp3,Yi0\\\"\\n    rollPitchP = 0.5\\n    rollPitchI = 0\\n    rollPitchD = 15\\n\\n    let radioGroup = 7\\n    let motorSpeed = -1\\n\\n\\n\\n\\n\\n}\\n\\n\",\"main.blocks\":\"<xml xmlns=\\\"https://developers.google.com/blockly/xml\\\"><variables><variable id=\\\"TD{ra*m9HXG22Q~vWK2^\\\">index</variable><variable id=\\\":RyIFg*?=ose1eu/_=7H\\\">index2</variable><variable id=\\\":{d)dS-}qkG~+LR9(hX6\\\">roll</variable><variable id=\\\"sbmQRWi)#3OMt;$,OAfC\\\">pitch</variable><variable id=\\\"U[AYI%;*Hoo_XMmmI+$9\\\">arm</variable><variable id=\\\":Povv@~Q{Krd-#u^}FSl\\\">mode</variable><variable id=\\\"PMEVcy5]IvD9mu,2=qJb\\\">throttle</variable><variable id=\\\"nxrix2ztCW/^7hn2vVH5\\\">motorTesting</variable><variable id=\\\"#osT^rph8SLg6~WYR?e4\\\">imuRoll</variable><variable id=\\\"3XQyF*mF$%N(hT:e_P.}\\\">stable</variable><variable id=\\\"Bl$C1xID3r{K*RMzH,0u\\\">mcExists</variable><variable id=\\\"a|xq#S02n)?6*DPTyhJs\\\">gyroExists</variable><variable id=\\\"_)PN4#C|`7sGHLQXOhm!\\\">notCharging</variable><variable id=\\\"wX.bskE(~-LhiyB}JzC)\\\">motorA</variable><variable id=\\\"z2bo#}cJ-!]8{PG(=e1s\\\">motorB</variable><variable id=\\\"p~)Aw;Xi{kn6WLSRA~Ld\\\">motorC</variable><variable id=\\\"G,,!k0pPUKK51Vwm}r=S\\\">motorD</variable><variable id=\\\".wo]?p:fMG1?%W(NjsXx\\\">cpuTime</variable><variable id=\\\"SZZncGA{(j}Jia]5W`%S\\\">startTime</variable><variable id=\\\"~bb1r)KvDxH8txDl}7+w\\\">imuPitch</variable><variable id=\\\"Wv:$9=(jdb_gnI_M:sRa\\\">batterymVoltSmooth</variable><variable id=\\\"HO*Zyck6kRpvQ^K(MgeA\\\">radioReceivedTime</variable><variable id=\\\"QI:BTI/OFIBFt@`N2Au/\\\">yaw</variable><variable id=\\\"g7|}HBiY}KuSQ#iv_uGn\\\">AnalogP0Switch</variable><variable id=\\\"mnIf_/mEY=zqX+w#WJgZ\\\">index3</variable><variable id=\\\"Hp]bT$zz=@K#U%%M7);u\\\">expoSetting</variable><variable id=\\\"6m]z0M[}e#i},Y:[mz5p\\\">expoFactor</variable><variable id=\\\"KD(I_U%YDMl*Db?4+nx-\\\">imuYaw</variable><variable id=\\\"bTGyzaY!--7Yq_l!K+Dq\\\">baroExists</variable><variable id=\\\"aP/B3oJgB+xvyeeh:P{G\\\">batteryVolt</variable><variable id=\\\"leU(6$[Df,gxG*_7`wxw\\\">radioGroup</variable><variable id=\\\"0p^L%;jrS[~,!(ycPB#I\\\">rollPitchP</variable><variable id=\\\"?|aNZ,:pU%}.aA1$:Rq*\\\">rollPitchI</variable><variable id=\\\"/`W-9PQ(cy^CP!P4QDj%\\\">rollPitchD</variable><variable id=\\\"d:*+t!H{4HpwMNR@dl$@\\\">yawP</variable><variable id=\\\"QP%6E+uKS^5[;9@AW-6$\\\">yawD</variable></variables><block type=\\\"pxt-on-start\\\" x=\\\"-905\\\" y=\\\"-332\\\"><statement name=\\\"HANDLER\\\"><block type=\\\"controls_repeat_ext\\\"><value name=\\\"TIMES\\\"><shadow type=\\\"math_whole_number\\\"><field name=\\\"NUM\\\">4</field></shadow></value><statement name=\\\"DO\\\"><block type=\\\"airbit_PCA_Start\\\"><next><block type=\\\"airbit_MotorSpeed\\\"><value name=\\\"m0\\\"><shadow type=\\\"math_number_minmax\\\"><mutation min=\\\"0\\\" max=\\\"255\\\" label=\\\"M0\\\" precision=\\\"0\\\"></mutation><field name=\\\"SLIDER\\\">255</field></shadow></value><value name=\\\"m1\\\"><shadow type=\\\"math_number_minmax\\\"><mutation min=\\\"0\\\" max=\\\"255\\\" label=\\\"M1\\\" precision=\\\"0\\\"></mutation><field name=\\\"SLIDER\\\">255</field></shadow></value><value name=\\\"m2\\\"><shadow type=\\\"math_number_minmax\\\"><mutation min=\\\"0\\\" max=\\\"255\\\" label=\\\"M2\\\" precision=\\\"0\\\"></mutation><field name=\\\"SLIDER\\\">255</field></shadow></value><value name=\\\"m3\\\"><shadow type=\\\"math_number_minmax\\\"><mutation min=\\\"0\\\" max=\\\"255\\\" label=\\\"M3\\\" precision=\\\"0\\\"></mutation><field name=\\\"SLIDER\\\">255</field></shadow></value><next><block type=\\\"airbit_rotateDot\\\"><value name=\\\"xPos\\\"><shadow type=\\\"math_number_minmax\\\"><mutation min=\\\"0\\\" max=\\\"4\\\" label=\\\"XPos\\\" precision=\\\"0\\\"></mutation><field name=\\\"SLIDER\\\">4</field></shadow></value><value name=\\\"yPos\\\"><shadow type=\\\"math_number_minmax\\\"><mutation min=\\\"0\\\" max=\\\"4\\\" label=\\\"YPos\\\" precision=\\\"0\\\"></mutation><field name=\\\"SLIDER\\\">4</field></shadow></value><value name=\\\"radius\\\"><shadow type=\\\"math_number_minmax\\\"><mutation min=\\\"1\\\" max=\\\"4\\\" label=\\\"Radius\\\" precision=\\\"0\\\"></mutation><field name=\\\"SLIDER\\\">4</field></shadow></value><value name=\\\"speed\\\"><shadow type=\\\"math_number_minmax\\\"><mutation min=\\\"-100\\\" max=\\\"100\\\" label=\\\"Speed\\\" precision=\\\"0\\\"></mutation><field name=\\\"SLIDER\\\">100</field></shadow></value></block></next></block></next></block></statement></block></statement></block></xml>\",\"main.ts\":\"for (let index = 0; index < 4; index++) {\\n    airbit.PCA_Start()\\n    airbit.MotorSpeed(\\n    255,\\n    255,\\n    255,\\n    255\\n    )\\n    airbit.rotateDot(\\n    4,\\n    4,\\n    4,\\n    100\\n    )\\n}\\n\",\"pxt.json\":\"{\\n    \\\"name\\\": \\\"air bit\\\",\\n    \\\"description\\\": \\\"\\\",\\n    \\\"dependencies\\\": {\\n        \\\"core\\\": \\\"*\\\",\\n        \\\"radio\\\": \\\"*\\\",\\n        \\\"microphone\\\": \\\"*\\\",\\n        \\\"microbit-pxt-i2cpins\\\": \\\"github:bsiever/microbit-pxt-i2cpins#v0.0.6\\\"\\n    },\\n    \\\"files\\\": [\\n        \\\"main.blocks\\\",\\n        \\\"main.ts\\\",\\n        \\\"README.md\\\",\\n        \\\"custom.ts\\\"\\n    ],\\n    \\\"testFiles\\\": [\\n        \\\"test.ts\\\"\\n    ],\\n    \\\"targetVersions\\\": {\\n        \\\"branch\\\": \\\"v3.0.61\\\",\\n        \\\"tag\\\": \\\"v3.0.61\\\",\\n        \\\"commits\\\": \\\"https://github.com/microsoft/pxt-microbit/commits/9ff91acb8524c6a52fee90cf7194a4643c424363\\\",\\n        \\\"target\\\": \\\"4.0.16\\\",\\n        \\\"pxt\\\": \\\"6.0.35\\\",\\n        \\\"targetId\\\": \\\"microbit\\\"\\n    },\\n    \\\"supportedTargets\\\": [\\n        \\\"microbit\\\"\\n    ],\\n    \\\"preferredEditor\\\": \\\"blocksprj\\\"\\n}\\n\",\"test.ts\":\"// tests go here; this will not be compiled when this package is used as an extension.\\n\"}","pxt.json":"{\n    \"name\": \"probando lo que chatgpt dice\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"air bit\": \"pkg:air bit.json\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"air bit.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1735320863726}